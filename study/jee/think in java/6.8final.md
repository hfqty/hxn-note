final关键字的含义会随着语境不同产生差异
但它最一般的意思就是声明这个东西不能改变
之所以要禁止改变，可能是考虑两方面的因素：设计或效率

final 数据
许多程序设计语言都有自己的办法告诉编译器某个数据是常数，

常数主要应用于一下两个方面，
(1)编译器常数，它永远不会改变
(2)在运行期间初始化的一个值，我们不希望它改变，

无论是static还是final字段，都只能存储一个数据，而且不得改变

final 方法
为什么使用final
或者
使用final的场景

使用final方法，可能处于两方面的理由的考虑
* 第一个是为方法上锁
  防止任何继承类改变它的本来含义，设计程序时，若希望一个方法的行为在继承期间保持不变，
  而且不可被覆盖或改写，就可以采取这种做法
* 第二个是为程序执行的效率
  将一个方法设成final后，编译器就可以把对那个方法的所有调用都嵌入调用里，只要编译器
  发现一个final方法调用，就会忽略为执行方法调用机制而采用的常规代码插入方法堆栈，
  跳至方法代码并执行它，跳回来，清除堆栈自变量，最后对返回值进行处理

类内所有private方法都会自动成为final，由于我们不能访问一个private方法，所以他绝对不会
被其他方法覆盖，可为一个private方法添加final指示符，但却不能为那个方法提供任何额外的含义


final 类
  如果整个类都是final，就表明自己不希望从这个类继承，或者不允许其他任何人采取这种操作，
  或者处于安全的原因，我们不希望进行子类化，除此以外，我们或许还考虑到执行效率的问题，并想
  确保涉及这个类各对象的所有行动都要尽可能有效

final 注意事项
  设计一个类时，往往需要考虑是否将一个方法设为final，可能会觉得使用自己的类时执行效率
  非常重要，没有人想要覆盖自己的方法，
  这种想法在某些时候是正确的，但要慎重作出自己的假定，通常，我们很难预测一个类，以后会以什么
  样的形式再生或重复利用，常规用途的类尤其如此。若将一个方法定义成final，就可能杜绝了其他
  程序员的项目中对自己的类进行继承的途径，因为我们根本没想到他会像那样使用

  标准的java库是阐述这一观点的最好例子，其中他别常用的一个类是Vector，如果我们考虑代码的执
  行效率，就会发现不把任何方法设为final，才能使其发挥更大的作用，我们很容易就会想到自己应继承
  和覆盖如此有用的一个类，但它的设计者却否定了我们的想法，但我们至少可以用两个理由来反驳他们，
  首先，Stack是从Vector继承来的，亦即Stack是一个Vector，这种说法是不确切的，其次，对于
  Vector许多重要的方法，如addElement()以及elementAt(),它们都变成了synchronized。

  另一个值得注意的是hashtable，它是另一个重要的标准类，该类没有采用任何final方法，正如我们在本书
  其他地方提到的那样，显然一些类的设计人员和其他类的设计人员有着全然不同的素质，注意比较Hashtable
  极端的方法名与Vector的方法名
  对类库的用户来说，这显然不应该是如此轻易就被看出的

  
