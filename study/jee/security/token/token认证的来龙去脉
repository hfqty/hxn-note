2018年5月4日 10:15:10
不久前,我在前后端分离实践中提到了基于token的认证,现在我们稍稍深入一些
通常情况下,我们在讨论某个技术的时候,都是从一个问题开始,那么第一个问题:

为什么要用token?

而要回答这个问题很简单---因为他能解决问题!

可以解决哪些问题呢?

1.token完全由应用管理,所以它可以避开同源策略
2.token可以避免csrf攻击
3.token可以是无状态的,可以在多个服务间共享

token是在服务端产生的.如果前段使用用户名/密码向服务端请求认证,服务端认证成功,那么服务端
会返回token给前端.前端可以在每次请求的时候带上token证明自己的合法地位.如果这个token在
服务端持久化(比如存入数据库),那它就是一个永久的身份令牌

于是,又一个问题产生了:需要为token设置有效期吗?

需要设置有效期吗?

对于这个问题,我们不妨先看两个例子,一个例子是登录密码,一般要求定期改变密码.以防止泄漏,所以
密码是有有效期的;另一个例子是安全证书,ssl安全证书都有有效期,目的是为了解决吊销的问题,对于
对于这个问题的详细情况,知乎-https://www.zhihu.com/question/20803288
所以无论从安全的角度考虑,还是从吊销的角度考虑,token都需要设置有效期

那么有效期多长时间合适呢?

只能说,根据系统的需要,尽可能的短,但也不能短的离谱---想象一下手机的自动熄屏时间,如果设置为
10秒钟误操作自动熄屏,再次点亮需要输入密码.会不会疯?如果你觉得不会,那就亲自试一试,设置成
可以设置的最短时间,坚持一周就好,

然后问题就产生了,如果用户在正常使用过程中头儿可能过期失效了,要求用户重新登录,用户体验岂不是
很糟糕

为了解决在操作过程不能让用户感受到token失效这个问题,有一种方案是在服务器保存token状态,用户
每次操作都会自动刷新token的过期时间---session就是采用这种策略来保持用户登录状态的,然而仍然存
这样一个问题,在前后端分离,单页app这些情况下,每秒钟可能发起很多次请求,每次都去刷新过期时间
会产生非常大的代价,如果token的过期时间被持久化到数据库或文件,代价就更大了,所以通常为了提升
效率,减少消耗,会把token的过期时间保存在缓存或者内存中,

还有一种方案,使用refresh token ,它可以避免频繁的读写操作,这种方案中,服务端不需要刷新token
的过期时间,一旦token过期,就反馈给前端,前端使用refresh token 申请一个全新的token继续使用
这种方案中,服务端只需要在客户端请求更新token的时候对refresh token 的有效性进行一次检查,
大大减少了更新有效期的操作,也就避免了频繁读写,当然refresh token 也是有有效期的,但是这个
有效期就可以长一点了,比如,以天为单位的时间

时序图表示

使用token和refresh token 的时序图如下

1.登录

前端-----请求登录[user,pass]----服务器

服务器-----认证[user,pass]--通过

服务器-----创建refresh token

服务器-----创建与refresh token 关联token

服务器----发送[token,refresh token]----前端




上面的时序图中并未提到refresh token 过期怎么办,不过很显然,refresh token 既然已经过期,
就应该要求用户重新登录了

当然还可以把这个机制设计的更复杂一些,比如refresh token 每次使用的时候,都更新它的过期时间,
直到与它的创建时间相比,已经超过了非常长的一段时间(比如三个月),这等于是在想当一段时间内
允许refresh token 自动续期

到目前为止,token都是有状态的,即在服务端需要保存并记录相关属性,那说好的无状态呢,怎么实现?



无状态token

如果我们把所有状态信息都附加在token上,服务器就可以不保存,但是服务端仍然需要认证token有效,
不过只要服务端能确认是自己签发的token,而且其信息未被改动过,那就可以认为token有效---签名
可以作此保证,平时所常说的签名都存在一方签发,另一方验证的情况,所以要使用非对称加密算法,
但是在这里,签发和验证都是同一方,所以对称加密算法就能达到要求,而对称算法比非对称算法要快的多,
更进一步思考,对称加密算法除了加密,还带有原加密内容的功能,而这一功能在对token签名时并无必要
既然不需要解密,摘要算法就会更快,可以指定密码的散列算法,自然是HMAC

上面说了那么多,还需要自己去实现吗?
不用!jwt已经定义了详细的规范,而且有各种语言的若干实现

不过在使用无状态token的时候服务端就会有一些变化,服务端虽然不保存有效的token了,确需要保存
未到期却已注销的token,如果一个token未到期就被用户主动注销,那么服务器需要保存这个被注销的
token,以便下次收到使用这个仍在有效期内的token时判其无效,有没有感到一点沮丧?

在前端可控的情况下,可以协商:前端一旦注销成功,就丢掉本地保存的token和refresh token.基于这样
的约定服务器就可以假设收到的token一定是没注销的

如果前端不可控的情况,仍然可以进行上面的假设,但是在这种情况下,需要尽量缩短token的有效期,
而且必须再用户主动注销的情况下让refresh token无效.这个操作存在一定的安全漏洞,因为用户会认
为已经注销了,实际上在较短的时间内并没有注销,如果应用设计中,这点漏洞并不会造成设什么损失,
那采用这种策略就是可行的

在使用无状态token 的时候,有两点需要注意

1.refresh token 有效时间较长,所以他应该在服务器端有状态,以增强安全性,确保用户注销时可
控
2. 应该考虑使用二次认证来增强敏感操作的安全性

到此,关于token的话题似乎差不多了--然而,并没有,上面说的只是认证服务和业务服务集成在一起的
情况,如果是分离的情况呢?

分离认证服务

当token无状态之后,单点登录就变得容易了.前端拿到一个有效的token,它就可以在任何统一体系的服
务上认证通过---只要它们使用相同的密钥和算法来认证token的有效性,就像这样:

可见,虽然认证和业务分离了,实际却并没有产生多大的差异.当然,这是建立在认证服务器信任业务服务
器的前提下,因为认证服务器产生token密钥和业务服务器认证token的密钥和算法相同.换句话说,业务
服务器同样可以创建有效的token

如果业务服务器不能被信任,该怎么办?

不受信的业务服务器

遇到不受信的业务服务器时,很容易想到的办法是使用不同的密钥.认证服务器使用密钥1签发,业务服务器
使用密钥2验证---这是典型非对称加密的应用场景.认证服务器对自己使用token签名,公开公钥.信
任这个认证服务器的业务服务器保存公钥,用于验证签名.幸好,jwt不仅可以使用hmac签名,也可以使用
rsa签名

不过,当业务服务器已经不受信任的时候,多个业务服务器之间使用相同的token对用户来说是不安全的.
因为任何一个服务器拿到token都可以仿冒用户去另一个服务器处理业务---悲剧随时可能发生

为了防止这种情况发生,就需要在认证服务器产生token的时候,把使用该token的业务服务器的信息记录
在token中,这样当另一个业务服务器拿到这个token的时候,发现它并不是自己应该验证的token,就可以
直接拒绝

现在,认证服务器不信任业务服务器,业务服务器也相互不信任,但前端是信任这些服务器的---如果前端
不信任,就不会拿token去验证请求.那么为什么会信任?可能是因为这是同一家公司或者同一个项目中
提供的若干服务构成的服务体系

但是,前端信任不代表用户信任,如果token并没有携带用户隐私,比如姓名,那么用户不会关心信任问题
但如果token含有用户隐私的时候,用户得关心信任问题了,这时候认证服务就不得不再罗嗦一些,当
用户请求token的时候,问上一句,你真的需要授权给某某业务服务吗?

为了得到用户得信任,认证服务就不得不帮助用户来甄别业务服务,所以,认证服务器决定不公开公钥
而是要求业务服务先申请注册并通过审核.只有通过审核的业务服务器才能得到认证服务为它所创建
的,仅供它使用的公钥.如果该业务服务泄漏公钥带来风险,又该业务服务自行承担,现在认证服务可
以清楚的告诉用户,某某某服务是什么了,如果用户还是不够信任,认证服务甚至可以问,某某某业务
服务需要请求a,b,c三项个人数据,其中a是必须的,不然它不工作,是否允许授权,如果你授权,我就把你
授权的几项数据加密放在token中

废话了这么多,有没有似曾相识...对了,这类似开放式api的认证过程,开放式api采用oauth认证,而
关于oauth的探讨资源非常丰富,这里就不探究了
